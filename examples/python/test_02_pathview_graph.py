#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PathSim Simulation
==================

Converted from: test_02_pathview_graph.pvm
Generated by pvm2py on 2026-02-26 11:21:42
https://view.pathsim.org

PathSim documentation: https://docs.pathsim.org
"""

# ────────────────────────────────────────────────────────────────────────────
# IMPORTS
# ────────────────────────────────────────────────────────────────────────────

import numpy as np
import matplotlib.pyplot as plt

from pathsim import Simulation, Connection
from pathsim.blocks import (
    Adder,
    Amplifier,
    Function,
    Scope,
    Source,
    StepSource
)
from pathsim.solvers import SSPRK22

# ────────────────────────────────────────────────────────────────────────────
# USER-DEFINED CODE
# ────────────────────────────────────────────────────────────────────────────

import os
# make sure to: pip install jsbsim
import jsbsim
import xml.etree.ElementTree as ET
import matplotlib.pyplot as plt

# Relative path to the directory where the flight model is stored
# Note - Aircraft directory needs to be writeable in order to modify the cg
PATH_TO_JSBSIM_FILES="../.."

print(f'=================================================================')
print(f'Current working directory: {os.getcwd()}')

# Global variables that must be modified to match your particular need
# The aircraft name
# Note - It should match the exact spelling of the model file
AIRCRAFT_NAME="global5000"

# Avoid flooding the console with log messages
jsbsim.FGJSBBase().debug_lvl = 0

# Instantiate the FDMExec object and load the aircraft
fdm = jsbsim.FGFDMExec(PATH_TO_JSBSIM_FILES)

load_status = fdm.load_model(AIRCRAFT_NAME)

pm = fdm.get_property_manager()

print(f'=================================================================')

ac_xml_tree = ET.parse(os.path.join(fdm.get_root_dir(), f'aircraft/{AIRCRAFT_NAME}/{AIRCRAFT_NAME}.xml'))
ac_xml_root = ac_xml_tree.getroot()

# Get the empty weight from aircraft xml [assume lbs]
for x in ac_xml_root.findall('mass_balance'):
        w = x.find('emptywt').text

empty_weight = float(w)

# Get the original CG from aircraft xml, assum inches from Construction axes origin
for loc in ac_xml_root.findall('mass_balance/location'):
        x_cg_ = loc.find('x').text

x_cg_0 = float(x_cg_)

# Assume a payload, midweight, lb
payload_0 = 15172/2

# Fuel max for Global5000, lbm
fuelmax = 8097.63

# Assume the mass of fuel, half tanks, lb
fuel_per_tank = fuelmax/2


# Select a speed to run the simulation at, knots
speed_cas = 250

# Assume a flight altitude
h_ft_0 = 15000

# Fuel max for Global5000, lbm
fuelmax = 8097.63

weight_0 = empty_weight + payload_0 + fuel_per_tank*3

# Assume a zero flight path angle, gamma_0
gamma_0 = 0

print("-----------------------------------------")
print("Altitude {} ft, Weight {} lb, CoG-x {} in".format(h_ft_0, weight_0, x_cg_0))
print("-----------------------------------------")
print("Running simulation at initial CAS = {} kn, and Altitude = {} ft".format(speed_cas, h_ft_0))
print("-----------------------------------------")

# Set engines running
fdm['propulsion/set-running'] = -1
trim_results = []
trim_results_fcs = []

fdm['ic/h-sl-ft'] = h_ft_0
fdm['ic/vc-kts'] = speed_cas
fdm['ic/gamma-deg'] = gamma_0
fdm['propulsion/tank[0]/contents-lbs'] = fuel_per_tank
fdm['propulsion/tank[1]/contents-lbs'] = fuel_per_tank
fdm['propulsion/tank[2]/contents-lbs'] = fuel_per_tank
fdm['inertia/pointmass-weight-lbs[0]'] = payload_0

# Initialize the aircraft with initial conditions
fdm.run_ic()

# Run fdm model
fdm.run()

# Trim the aircraft to initial conditions
fdm['simulation/do_simple_trim'] = 1
fdm.run()

print("-----------------------------------------")

trim_results.append((fdm['velocities/vc-kts'], fdm['aero/alpha-deg']))
trim_results_fcs.append((fdm['fcs/elevator-pos-rad'], fdm['fcs/elevator-pos-deg'], fdm['fcs/elevator-pos-norm']))

# Print trim results
print("Trim results:")
print("CAS (knots): {}\nAoA (deg): {}".format(trim_results[0][0], trim_results[0][1]))
print("Elevator pos (rad): {}\nElevator pos (deg): {}\nElevator pos (norm): {}".format(trim_results_fcs[0][0], trim_results_fcs[0][1], trim_results_fcs[0][2]))
print("-----------------------------------------")

# An example of 'Dynamical function' that takes the elevator command as input and outputs the angle of attack
def f_aircraft(u):
    # PathSim passes u as a 1-D numpy array (shape (1,)), and recent numpy versions reject float() on non-0-dimensional arrays. 
    # The fix is to use .flat[0] to extract the scalar regardless of array shape.
    fdm["fcs/elevator-cmd-norm"] = float(np.asarray(u).flat[0]) 
    fdm.run()
    alpha_ = pm.get_node('aero/alpha-deg').get_double_value()
    return alpha_

# Constant signal function that outputs the elevator command (normalized) at trim
def f_elevator_command_at_trim(t):
    return trim_results_fcs[0][2]

# ────────────────────────────────────────────────────────────────────────────
# BLOCKS
# ────────────────────────────────────────────────────────────────────────────

trim_elevator_cmd_delta_textcmde0 = Source(
    func=f_elevator_command_at_trim
)
adder_sigma = Adder(
    operations='++'
)
command_deltadelta_textcmdet = StepSource(
    amplitude=[-0.1, 0, 0.1, 0],
    tau=[10, 11, 12, 13]
)
amplifier_times_100 = Amplifier(
    gain=100
)
alpha__fbigdelta_textcmdetbig = Function(
    func=f_aircraft
)
aoa_alphat = Scope()
command_perc_delta_textcmdet = Scope()

blocks = [
    trim_elevator_cmd_delta_textcmde0,
    adder_sigma,
    command_deltadelta_textcmdet,
    amplifier_times_100,
    alpha__fbigdelta_textcmdetbig,
    aoa_alphat,
    command_perc_delta_textcmdet,
]

# ────────────────────────────────────────────────────────────────────────────
# CONNECTIONS
# ────────────────────────────────────────────────────────────────────────────

connections = [
    Connection(trim_elevator_cmd_delta_textcmde0[0], adder_sigma[0]),
    Connection(command_deltadelta_textcmdet[0], adder_sigma[1]),
    Connection(adder_sigma[0], amplifier_times_100[0], alpha__fbigdelta_textcmdetbig[0]),
    Connection(alpha__fbigdelta_textcmdetbig[0], aoa_alphat[0]),
    Connection(amplifier_times_100[0], command_perc_delta_textcmdet[0]),
]

# ────────────────────────────────────────────────────────────────────────────
# SIMULATION
# ────────────────────────────────────────────────────────────────────────────

sim = Simulation(
    blocks,
    connections,
    Solver=SSPRK22,
    dt=0.008333,
    dt_min=1e-12,
    dt_max=1e-2,
    tolerance_lte_rel=1e-3,
    tolerance_lte_abs=1e-6,
    tolerance_fpi=1e-12,
)

# ────────────────────────────────────────────────────────────────────────────
# MAIN
# ────────────────────────────────────────────────────────────────────────────

if __name__ == '__main__':

    # Run simulation
    sim.run(duration=40.0)

    # Plot results
    sim.plot()
    plt.show()
